{\rtf1\ansi{\fonttbl{\f0\fswiss Courier New;}{\f1\fswiss Arial;}{\f2\fswiss Wingdings;}{\f3\fswiss MS Sans Serif;}}{\colortbl\red0\green0\blue196;\red100\green0\blue255;\red0\green0\blue255;}
\sa50\sb50\f3\fs20
#{\footnote # IDH_Class_TJvHidDevice}
${\footnote $ TJvHidDevice}
K{\footnote K TJvHidDevice}
A{\footnote A TJvHidDevice_Object;TJvHidDevice}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50
{\keepn{\{bml usb.bmp\}\f1\fs28  \cf2 TJvHidDevice Object}\line
{\fs20{\ul Hierarchy\v IDH_Anym_3FAMT_1}    {\uldb Properties\v pme_cp_TJvHidDevice>pme}   {\uldb Methods\v pme_cm_TJvHidDevice>pme}   {\uldb Events\v pme_ce_TJvHidDevice>pme}\tab{\uldb Utilities\v pme_ce_Utilities>pme}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDevice = \b class\b0 (TObject)}\par\pard\sa0\sb0
{#{\footnote # IDH_ClassTopic_TJvHidDevice_Properties}}
A TJvHidDevice object represents a physical HID device. All static informations of the 
device have been read into properties of the object. The object is created at runtime 
by a TJvHidDeviceController which reigns all TJVHidDevice object.
\par\page

#{\footnote # pme_cp_TJvHidDevice}
${\footnote $ Properties for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50
{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Properties\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDevice\b0\line
\{bmct readonly.bmp\}\tab{\uldb Attributes\v IDH_TJvHidDevice_Attributes>Main}\line
\{bmct readonly.bmp\}\tab{\uldb Caps\v IDH_TJvHidDevice_Caps>Main}\line
\{bmct Published.bmp\}\tab{\uldb Configuration\v IDH_TJvHidDevice_Configuration>Main}\line
\{bmct readonly.bmp\}\tab{\uldb DevicePath\v IDH_TJvHidDevice_DevicePath>Main}\line
\{bmct readonly.bmp\}\tab{\uldb DeviceStrings\v IDH_TJvHidDevice_DeviceStrings>Main}\line
\{bmct readonly.bmp\}\tab{\uldb DevRegKey\v IDH_TJvHidDevice_DevRegKey>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidOverlappedHandle\v IDH_TJvHidDevice_HidOverlappedHandle>Main}\line
\{bmct readonly.bmp\}\tab{\uldb IsCheckedOut\v IDH_TJvHidDevice_IsCheckedOut>Main}\line
\{bmct readonly.bmp\}\tab{\uldb IsPluggedIn\v IDH_TJvHidDevice_IsPluggedIn>Main}\line
\{bmct readonly.bmp\}\tab{\uldb LanguageStrings\v IDH_TJvHidDevice_LanguageStrings>Main}\line
\{bmct readonly.bmp\}\tab{\uldb LinkCollectionNodes\v IDH_TJvHidDevice_LinkCollectionNodes>Main}\line
\{bmct Published.bmp\}\tab{\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}\line
\{bmct readonly.bmp\}\tab{\uldb MaxButtonListLength\v IDH_TJvHidDevice_MaxButtonListLength>Main}\line
\{bmct readonly.bmp\}\tab{\uldb MaxDataListLength\v IDH_TJvHidDevice_MaxDataListLength>Main}\line
\{bmct readonly.bmp\}\tab{\uldb MaxUsageListLength\v IDH_TJvHidDevice_MaxUsageListLength>Main}\line
\{bmct Published.bmp\}\tab{\uldb NumInputBuffers\v IDH_TJvHidDevice_NumInputBuffers>Main}\line
\{bmct Published.bmp\}\tab{\uldb NumOverlappedBuffers\v IDH_TJvHidDevice_NumOverlappedBuffers>Main}\line
\{bmct readonly.bmp\}\tab{\uldb PhysicalDescriptor\v IDH_TJvHidDevice_PhysicalDescriptor>Main}\line
\{bmct readonly.bmp\}\tab{\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}\line
\{bmct readonly.bmp\}\tab{\uldb ProductName\v IDH_TJvHidDevice_ProductName>Main}\line
\{bmct readonly.bmp\}\tab{\uldb RegClass\v IDH_TJvHidDevice_RegClass>Main}\line
\{bmct readonly.bmp\}\tab{\uldb RegDescr\v IDH_TJvHidDevice_RegDescr>Main}\line
\{bmct Published.bmp\}\tab{\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}\line
\{bmct readonly.bmp\}\tab{\uldb SerialNumber\v IDH_TJvHidDevice_SerialNumber>Main}\line
\{bmct Published.bmp\}\tab{\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}\line
\{bmct Published.bmp\}\tab{\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}\line
\{bmct readonly.bmp\}\tab{\uldb VendorName\v IDH_TJvHidDevice_VendorName>Main}
}\par\page

#{\footnote # pme_cm_TJvHidDevice}
${\footnote $ Methods for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Methods\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDevice\b0\line
\{bmct empty.bmp\}\tab{\uldb CloseFile\v IDH_TJvHidDevice_CloseFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb CloseFileEx\v IDH_TJvHidDevice_CloseFileEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb DeviceIoControl\v IDH_TJvHidDevice_DeviceIoControl>Main}\line
\{bmct empty.bmp\}\tab{\uldb Destroy\v IDH_TJvHidDevice_Destroy>Main}\line
\{bmct empty.bmp\}\tab{\uldb FlushQueue\v IDH_TJvHidDevice_FlushQueue>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetButtonCaps\v IDH_TJvHidDevice_GetButtonCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetButtons\v IDH_TJvHidDevice_GetButtons>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetButtonsEx\v IDH_TJvHidDevice_GetButtonsEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetData\v IDH_TJvHidDevice_GetData>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetFeature\v IDH_TJvHidDevice_GetFeature>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetScaledUsageValue\v IDH_TJvHidDevice_GetScaledUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetSpecificButtonCaps\v IDH_TJvHidDevice_GetSpecificButtonCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetSpecificValueCaps\v IDH_TJvHidDevice_GetSpecificValueCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsages\v IDH_TJvHidDevice_GetUsages>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsagesEx\v IDH_TJvHidDevice_GetUsagesEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsageValue\v IDH_TJvHidDevice_GetUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsageValueArray\v IDH_TJvHidDevice_GetUsageValueArray>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetValueCaps\v IDH_TJvHidDevice_GetValueCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb ReadFile\v IDH_TJvHidDevice_ReadFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb ReadFileEx\v IDH_TJvHidDevice_ReadFileEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetButtons\v IDH_TJvHidDevice_SetButtons>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetData\v IDH_TJvHidDevice_SetData>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetFeature\v IDH_TJvHidDevice_SetFeature>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetScaledUsageValue\v IDH_TJvHidDevice_SetScaledUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetUsages\v IDH_TJvHidDevice_SetUsages>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetUsageValue\v IDH_TJvHidDevice_SetUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetUsageValueArray\v IDH_TJvHidDevice_SetUsageValueArray>Main}\line
\{bmct empty.bmp\}\tab{\uldb UnsetButtons\v IDH_TJvHidDevice_UnsetButtons>Main}\line
\{bmct empty.bmp\}\tab{\uldb UnsetUsages\v IDH_TJvHidDevice_UnsetUsages>Main}\line
\{bmct empty.bmp\}\tab{\uldb WriteFile\v IDH_TJvHidDevice_WriteFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb WriteFileEx\v IDH_TJvHidDevice_WriteFileEx>Main}
}\par\page

#{\footnote # pme_ce_TJvHidDevice}
${\footnote $ Events for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Events\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDevice\b0\line
\{bmct Published.bmp\}\tab{\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main}
}\par\page

#{\footnote # IDH_TJvHidDevice_Attributes}
${\footnote $ TJvHidDevice.Attributes}
K{\footnote K TJvHidDevice,Attributes;Attributes,TJvHidDevice;Attributes}
A{\footnote A TJvHidDevice_Attributes;Attributes_Property;Attributes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.Attributes\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Attributes: THIDDAttributes;}\par
{\f0 THIDDAttributes = packed record\line
  Size:          ULONG;\line
  VendorID:      Word;\line
  ProductID:     Word;\line
  VersionNumber: Word;\line
end;\par}
The global unique Vendor ID, Product ID and Version of the device. 
The values come directly from the device. Size is of no importance. 
The record is read in with HidD_GetAttributes.
\par\page

#{\footnote # IDH_TJvHidDevice_Caps}
${\footnote $ TJvHidDevice.Caps}
K{\footnote K TJvHidDevice,Caps;Caps,TJvHidDevice;Caps}
A{\footnote A TJvHidDevice_Caps;Caps_Property;Caps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.Caps\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Caps: THIDPCaps;}\par
{\f0 THIDPCaps = packed record\line
  Usage:                     TUsage;\line
  UsagePage:                 TUsage;\line
  InputReportByteLength:     Word;\line
  OutputReportByteLength:    Word;\line
  FeatureReportByteLength:   Word;\line
  Reserved:                  array [0..16] of Word;\line\line
  NumberLinkCollectionNodes: Word;\line\line
  NumberInputButtonCaps:     Word;\line
  NumberInputValueCaps:      Word;\line
  NumberInputDataIndices:    Word;\line\line
  NumberOutputButtonCaps:    Word;\line
  NumberOutputValueCaps:     Word;\line
  NumberOutputDataIndices:   Word;\line
  NumberFeatureButtonCaps:   Word;\line
  NumberFeatureValueCaps:    Word;\line
  NumberFeatureDataIndices:  Word;\line
end;\par}
The capabilities of the device. Various sizes and counts of the device. 
The record is read in with HidP_GetCaps.
\par\page

#{\footnote # IDH_TJvHidDevice_Configuration}
${\footnote $ TJvHidDevice.Configuration}
K{\footnote K TJvHidDevice,Configuration;Configuration,TJvHidDevice;Configuration}
A{\footnote A TJvHidDevice_Configuration;Configuration_Property;Configuration}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.Configuration\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Configuration: THIDDConfiguration;}\par
{\f0 THIDDConfiguration = packed record\line
  cookie:         Pointer;\line
  size:           ULONG;\line
  RingBufferSize: ULONG;\line
end;\par}
This seems to describe the buffer size the driver allocates to receive packets from the device. 
Tests with a mouse and a keyboard showed that cookie is set on read. size seems untouched. 
A write failed.  
The record is read in with HidD_GetConfiguration and written with HidD_SetConfiguration.
\par\page

#{\footnote # IDH_TJvHidDevice_DevicePath}
${\footnote $ TJvHidDevice.DevicePath}
K{\footnote K TJvHidDevice,DevicePath;DevicePath,TJvHidDevice;DevicePath}
A{\footnote A TJvHidDevice_DevicePath;DevicePath_Property;DevicePath}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.DevicePath\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} DevicePath: {\b string};}\par
The path name which is is used to open the {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} 
of the device. This is a special path which starts with \'27\\\\.\\\'27 and names the driver of the device.
\par\page

#{\footnote # IDH_TJvHidDevice_DeviceStrings}
${\footnote $ TJvHidDevice.DeviceStrings}
K{\footnote K TJvHidDevice,DeviceStrings;DeviceStrings,TJvHidDevice;DeviceStrings}
A{\footnote A TJvHidDevice_DeviceStrings;DeviceStrings_Property;DeviceStrings}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.DeviceStrings\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} DeviceStrings[Idx: Byte]: string;}\par
The string array of all the strings from the firmware of the device. 
{\uldb VendorName\v IDH_TJvHidDevice_VendorName>Main}, {\uldb ProductName\v IDH_TJvHidDevice_ProductName>Main} 
and {\uldb SerialNumber\v IDH_TJvHidDevice_SerialNumber>Main} are in this array if set.\line
There may be empty strings in the array if the device does not return a string for a specific index. 
Index 0 will always return ''.
\par\page

#{\footnote # IDH_TJvHidDevice_DevRegKey}
${\footnote $ TJvHidDevice.DevRegKey}
K{\footnote K TJvHidDevice,DevRegKey;DevRegKey,TJvHidDevice;DevRegKey}
A{\footnote A TJvHidDevice_DevRegKey;DevRegKey_Property;DevRegKey}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.DevRegKey\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} DevRegKey: DWORD;}\par
Unique device instance ID. For each plugged device Windows assigns a unique number. 
Even for two devices of the same kind the number is different. 
The value serves as root entry to the registry values of this device. 
The registry key is formed of HKEY_DYN_DATA\\Config\~Manager\\Enum\\{\i DevRegKey}. 
Use the number with 8 hex digits. All devices of Windows have an entry there.
This is only valid for Windows 98. Windows 2000 uses another scheme to access 
the device registry entries.
\par\page


#{\footnote # IDH_TJvHidDevice_HidFileHandle}
${\footnote $ TJvHidDevice.HidFileHandle}
K{\footnote K TJvHidDevice,HidFileHandle;HidFileHandle,TJvHidDevice;HidFileHandle}
A{\footnote A TJvHidDevice_HidFileHandle;HidFileHandle_Property;HidFileHandle}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.HidFileHandle\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidFileHandle: THandle;}\par
The file handle of the device opened with\line
CreateFile({\uldb DevicePath\v IDH_TJvHidDevice_DevicePath>Main}, GENERIC_READ {\b or} GENERIC_WRITE,\line
  FILE_SHARE_READ {\b or} FILE_SHARE_WRITE, {\b nil}, OPEN_EXISTING, 0, 0);\line
The file is opened by the methods if needed. It stays open until explicitly closed with {\uldb CloseFile\v IDH_TJvHidDevice_CloseFile>Main} or 
the device is checked back in. You can open the file with the method {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}. 
\par\page

#{\footnote # IDH_TJvHidDevice_HidOverlappedHandle}
${\footnote $ TJvHidDevice.HidOverlappedHandle}
K{\footnote K TJvHidDevice,HidOverlappedHandle;HidOverlappedHandle,TJvHidDevice;HidOverlappedHandle}
A{\footnote A TJvHidDevice_HidOverlappedHandle;HidOverlappedHandle_Property;HidOverlappedHandle}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.HidOverlappedHandle\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidOverlappedHandle: THandle;}\par
The file handle of the device opened with\line
CreateFile({\uldb DevicePath\v IDH_TJvHidDevice_DevicePath>Main}, GENERIC_READ {\b or} GENERIC_WRITE,\line
  FILE_SHARE_READ {\b or} FILE_SHARE_WRITE, {\b nil}, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);\line
The file is opened by the methods if needed. It stays open until explicitly closed with {\uldb CloseFileEx\v IDH_TJvHidDevice_CloseFileEx>Main} or 
the device is checked back in. You can open the file with the method {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main}. 
Only the methods {\uldb ReadFileEx\v IDH_TJvHidDevice_ReadFileEx>Main} and {\uldb WriteFileEx\v IDH_TJvHidDevice_WriteFileEx>Main} need this file handle.
\par\page

#{\footnote # IDH_TJvHidDevice_IsCheckedOut}
${\footnote $ TJvHidDevice.IsCheckedOut}
K{\footnote K TJvHidDevice,IsCheckedOut;IsCheckedOut,TJvHidDevice;IsCheckedOut}
A{\footnote A TJvHidDevice_IsCheckedOut;IsCheckedOut_Property;IsCheckedOut}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.IsCheckedOut\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} IsCheckedOut: Boolean;}\par
A simple flag which tells you if the device has been checked out with one of the CheckOut-methods.
\par\page

#{\footnote # IDH_TJvHidDevice_IsPluggedIn}
${\footnote $ TJvHidDevice.IsPluggedIn}
K{\footnote K TJvHidDevice,IsPluggedIn;IsPluggedIn,TJvHidDevice;IsPluggedIn}
A{\footnote A TJvHidDevice_IsPluggedIn;IsPluggedIn_Property;IsPluggedIn}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.IsPluggedIn\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} IsPluggedIn: Boolean;}\par
The flag tells if the device of this object has been unplugged. All methods and all writes to properties 
will cease to work. Destruction of the {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} also pulls the plug.
\par\page

#{\footnote # IDH_TJvHidDevice_LanguageStrings}
${\footnote $ TJvHidDevice.LanguageStrings}
K{\footnote K TJvHidDevice,LanguageStrings;LanguageStrings,TJvHidDevice;LanguageStrings}
A{\footnote A TJvHidDevice_LanguageStrings;LanguageStrings_Property;LanguageStrings}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.LanguageStrings\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} LanguageStrings: TStringList;}\par
The list of all languages that are supported in the string descriptors of the device. 
The entries of the list are localized language names from Windows. The list may be empty.\line
Which of the languages Windows uses for {\uldb DeviceStrings\v IDH_TJvHidDevice_DeviceStrings>Main} is not 
documented. There is no way to specify the desired language with HID functions.
\par\page

#{\footnote # IDH_TJvHidDevice_LinkCollectionNodes}
${\footnote $ TJvHidDevice.LinkCollectionNodes}
K{\footnote K TJvHidDevice,LinkCollectionNodes;LinkCollectionNodes,TJvHidDevice;LinkCollectionNodes}
A{\footnote A TJvHidDevice_LinkCollectionNodes;LinkCollectionNodes_Property;LinkCollectionNodes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.LinkCollectionNodes\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} LinkCollectionNodes[Idx: WORD]: THIDPLinkCollectionNode;}\par
The array of all the link collection nodes of the device.\par
{\f0 THIDPLinkCollectionNode = packed record\line
  LinkUsage:        TUsage;\line
  LinkUsagePage:    TUsage;\line
  Parent:           Word;\line
  NumberOfChildren: Word;\line
  NextSibling:      Word;\line
  FirstChild:       Word;\line
  CollectionType:   BYTE;\line
  IsAlias:          BYTE;\line
  Reserved:         Word;\line
  UserContext:      Pointer;\line
end;}\par
The elements Parent, NextSibling and FirstChild span the tree of the nodes in the usual way.\line
Zero signals no link. {\b Be warned!} This is not always true!
\par\page

#{\footnote # IDH_TJvHidDevice_LinkCollectionParam}
${\footnote $ TJvHidDevice.LinkCollectionParam}
K{\footnote K TJvHidDevice,LinkCollectionParam;LinkCollectionParam,TJvHidDevice;LinkCollectionParam}
A{\footnote A TJvHidDevice_LinkCollectionParam;LinkCollectionParam_Property;LinkCollectionParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.LinkCollectionParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} LinkCollectionParam: WORD;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same link collection 
with more than one method reduces code by first setting LinkCollectionParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_MaxButtonListLength}
${\footnote $ TJvHidDevice.MaxButtonListLength}
K{\footnote K TJvHidDevice,MaxButtonListLength;MaxButtonListLength,TJvHidDevice;MaxButtonListLength}
A{\footnote A TJvHidDevice_MaxButtonListLength;MaxButtonListLength_Property;MaxButtonListLength}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.MaxButtonListLength\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} MaxButtonListLength: ULONG;}\par
The maximum number of elements {\uldb GetButtonCaps\v IDH_TJvHidDevice_GetButtonCaps>Main} can return. 
Use this value to allocate the right amount of memory.
\par\page

#{\footnote # IDH_TJvHidDevice_MaxDataListLength}
${\footnote $ TJvHidDevice.MaxDataListLength}
K{\footnote K TJvHidDevice,MaxDataListLength;MaxDataListLength,TJvHidDevice;MaxDataListLength}
A{\footnote A TJvHidDevice_MaxDataListLength;MaxDataListLength_Property;MaxDataListLength}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.MaxDataListLength\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} MaxDataListLength: ULONG;}\par
The maximum number of elements {\uldb GetData\v IDH_TJvHidDevice_GetData>Main} can return. 
Use this value to allocate the right amount of memory.
\par\page

#{\footnote # IDH_TJvHidDevice_MaxUsageListLength}
${\footnote $ TJvHidDevice.MaxUsageListLength}
K{\footnote K TJvHidDevice,MaxUsageListLength;MaxUsageListLength,TJvHidDevice;MaxUsageListLength}
A{\footnote A TJvHidDevice_MaxUsageListLength;MaxUsageListLength_Property;MaxUsageListLength}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.MaxUsageListLength\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} MaxUsageListLength: ULONG;}\par
The maximum number of elements {\uldb GetUsages\v IDH_TJvHidDevice_GetUsages>Main} 
or {\uldb GetUsagesEx\v IDH_TJvHidDevice_GetUsagesEx>Main} can return. 
Use this value to allocate the right amount of memory.
\par\page

#{\footnote # IDH_TJvHidDevice_NumInputBuffers}
${\footnote $ TJvHidDevice.NumInputBuffers}
K{\footnote K TJvHidDevice,NumInputBuffers;NumInputBuffers,TJvHidDevice;NumInputBuffers}
A{\footnote A TJvHidDevice_NumInputBuffers;NumInputBuffers_Property;NumInputBuffers}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.NumInputBuffers\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumInputBuffers: Integer;}\par
Tells the number of buffers for reports {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} uses. 
Assign a value to change the number of buffers. The property is read with HidD_GetNumInputBuffers and written 
with HidD_SetNumInputBuffers.
\par\page

#{\footnote # IDH_TJvHidDevice_NumOverlappedBuffers}
${\footnote $ TJvHidDevice.NumOverlappedBuffers}
K{\footnote K TJvHidDevice,NumOverlappedBuffers;NumOverlappedBuffers,TJvHidDevice;NumOverlappedBuffers}
A{\footnote A TJvHidDevice_NumOverlappedBuffers;NumOverlappedBuffers_Property;NumOverlappedBuffers}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.NumOverlappedBuffers\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumOverlappedBuffers: Integer;}\par
Tells the number of buffers for reports {\uldb HidOverlappedHandle\v IDH_TJvHidDevice_HidOverlappedHandle>Main} uses. 
Assign a value to change the number of buffers. The property is read with HidD_GetNumInputBuffers and written 
with HidD_SetNumInputBuffers.
\par\page

#{\footnote # IDH_TJvHidDevice_PhysicalDescriptor}
${\footnote $ TJvHidDevice.PhysicalDescriptor}
K{\footnote K TJvHidDevice,PhysicalDescriptor;PhysicalDescriptor,TJvHidDevice;PhysicalDescriptor}
A{\footnote A TJvHidDevice_PhysicalDescriptor;PhysicalDescriptor_Property;PhysicalDescriptor}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.PhysicalDescriptor\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} PhysicalDescriptor: {\b string};}\par
The physical descriptor of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string has been converted from Unicode to ANSI.
\par\page

#{\footnote # IDH_TJvHidDevice_PreparsedData}
${\footnote $ TJvHidDevice.PreparsedData}
K{\footnote K TJvHidDevice,PreparsedData;PreparsedData,TJvHidDevice;PreparsedData}
A{\footnote A TJvHidDevice_PreparsedData;PreparsedData_Property;PreparsedData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.PreparsedData\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} PreparsedData: PHIDPPreparsedData;}\par
PreparsedData is an opaque data structure which is needed in the implementation of most 
methods. It is exposed as property to allow to call the HID functions directly.
\par\page

#{\footnote # IDH_TJvHidDevice_ProductName}
${\footnote $ TJvHidDevice.ProductName}
K{\footnote K TJvHidDevice,ProductName;ProductName,TJvHidDevice;ProductName}
A{\footnote A TJvHidDevice_ProductName;ProductName_Property;ProductName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.ProductName\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} ProductName: {\b string};}\par
The product name of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string has been converted from Unicode to ANSI.
\par\page

#{\footnote # IDH_TJvHidDevice_RegClass}
${\footnote $ TJvHidDevice.RegClass}
K{\footnote K TJvHidDevice,RegClass;RegClass,TJvHidDevice;RegClass}
A{\footnote A TJvHidDevice_RegClass;RegClass_Property;RegClass}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.RegClass\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} RegClass: {\b string};}\par
The user friendly name of the HID class the device is in. 
{\uldb cHidKeyboardClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main} and 
{\uldb cHidMouseClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main} name two of the possible classes. 
\par\page

#{\footnote # IDH_TJvHidDevice_RegDescr}
${\footnote $ TJvHidDevice.RegDescr}
K{\footnote K TJvHidDevice,RegDescr;RegDescr,TJvHidDevice;RegDescr}
A{\footnote A TJvHidDevice_RegDescr;RegDescr_Property;RegDescr}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.RegDescr\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} RegDescr: {\b string};}\par
The user friendly description of the HID device from the registry. 
This description comes from the INF file which installed the driver or is synthesized by Windows. 
The description is localized.
\par\page

#{\footnote # IDH_TJvHidDevice_ReportTypeParam}
${\footnote $ TJvHidDevice.ReportTypeParam}
K{\footnote K TJvHidDevice,ReportTypeParam;ReportTypeParam,TJvHidDevice;ReportTypeParam}
A{\footnote A TJvHidDevice_ReportTypeParam;ReportTypeParam_Property;ReportTypeParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.ReportTypeParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} ReportTypeParam: THIDPReportType;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same report type 
with more than one method reduces code by first setting ReportTypeParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_SerialNumber}
${\footnote $ TJvHidDevice.SerialNumber}
K{\footnote K TJvHidDevice,SerialNumber;SerialNumber,TJvHidDevice;SerialNumber}
A{\footnote A TJvHidDevice_SerialNumber;SerialNumber_Property;SerialNumber}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.SerialNumber\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} SerialNumber: {\b string};}\par
The serial number string of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string has been converted from Unicode to ANSI.
\par\page

#{\footnote # IDH_TJvHidDevice_UsagePageParam}
${\footnote $ TJvHidDevice.UsagePageParam}
K{\footnote K TJvHidDevice,UsagePageParam;UsagePageParam,TJvHidDevice;UsagePageParam}
A{\footnote A TJvHidDevice_UsagePageParam;UsagePageParam_Property;UsagePageParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.UsagePageParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} UsagePageParam: TUsage;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same usage page 
with more than one method reduces code by first setting UsagePageParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_UsageParam}
${\footnote $ TJvHidDevice.UsageParam}
K{\footnote K TJvHidDevice,UsageParam;UsageParam,TJvHidDevice;UsageParam}
A{\footnote A TJvHidDevice_UsageParam;UsageParam_Property;UsageParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.UsageParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} UsageParam: TUsage;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same usage 
with more than one method reduces code by first setting UsageParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
Results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_VendorName}
${\footnote $ TJvHidDevice.VendorName}
K{\footnote K TJvHidDevice,VendorName;VendorName,TJvHidDevice;VendorName}
A{\footnote A TJvHidDevice_VendorName;VendorName_Property;VendorName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.VendorName\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} VendorName: {\b string};}\par
The vendor name of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string has been converted from Unicode to ANSI.
\par\page

#{\footnote # IDH_TJvHidDevice_CloseFile}
${\footnote $ TJvHidDevice.CloseFile}
K{\footnote K TJvHidDevice,CloseFile;CloseFile,TJvHidDevice;CloseFile}
A{\footnote A TJvHidDevice_CloseFile;CloseFile_Method;CloseFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.CloseFile\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} CloseFile;}\par
Closes the file handle {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} if opened. 
The file is automatically reopened when a method needs the file handle. 
Use {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main} to open the file if needed.\par
\par\page

#{\footnote # IDH_TJvHidDevice_CloseFileEx}
${\footnote $ TJvHidDevice.CloseFileEx}
K{\footnote K TJvHidDevice,CloseFileEx;CloseFileEx,TJvHidDevice;CloseFileEx}
A{\footnote A TJvHidDevice_CloseFileEx;CloseFileEx_Method;CloseFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.CloseFileEx\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} CloseFileEx;}\par
Closes the file handle {\uldb HidOverlappedHandle\v IDH_TJvHidDevice_HidOverlappedHandle>Main} if opened. 
The file is automatically reopened when a method needs the file handle. 
Use {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main} to open the file if needed.\par
\par\page

#{\footnote # IDH_TJvHidDevice_DeviceIoControl}
${\footnote $ TJvHidDevice.DeviceIoControl}
K{\footnote K TJvHidDevice,DeviceIoControl;DeviceIoControl,TJvHidDevice;DeviceIoControl}
A{\footnote A TJvHidDevice_DeviceIoControl;DeviceIoControl_Method;DeviceIoControl}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.DeviceIoControl\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} DeviceIoControl(IoControlCode: DWORD; InBuffer: Pointer; InSize: DWORD; 
OutBuffer: Pointer; OutSize: DWORD; {\b var} BytesReturned: DWORD): Boolean;}\par
Calls {\f0 Windows.DeviceIoControl({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, IoControlCode, InBuffer, InSize, OutBuffer, OutSize, BytesReturned, {\b nil});}\par
The return value comes from Windows.DeviceIoControl or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_Destroy}
${\footnote $ TJvHidDevice.Destroy}
K{\footnote K TJvHidDevice,Destroy;Destroy,TJvHidDevice;Destroy}
K{\footnote K TJvHidDevice,Destroy;Destroy,TJvHidDevice;Destroy}
A{\footnote A TJvHidDevice_Destroy;Destroy_Method;Destroy}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.Destroy\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b destructor} Destroy; {\b override};}\par
The destructor of the TJvHidDevice class. The constructor is not exposed. 
Only TJvHidDeviceController can (or should) create a TJvHidDevice object. 
If the device is checked out and plugged in the TJvHidDeviceController creates a new 
checked in object to represent this device.\line
As usual call the Free method of the object to destroy it. 
You may override the destructor if you like, but do not forget to call "{\b inherited} Destroy;" 
as last statement of the overridden destructor or the TJvHidDeviceController component cannot clean up correctly.
\par\page

#{\footnote # IDH_TJvHidDevice_FlushQueue}
${\footnote $ TJvHidDevice.FlushQueue}
K{\footnote K TJvHidDevice,FlushQueue;FlushQueue,TJvHidDevice;FlushQueue}
A{\footnote A TJvHidDevice_FlushQueue;FlushQueue_Method;FlushQueue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.FlushQueue\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} FlushQueue: Boolean;}\par
Calls {\f0 HidD_FlushQueue({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main});} to delete all pending information from the input queue of the device.\par
The return value comes from HidD_FlushQueue or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_GetButtonCaps}
${\footnote $ TJvHidDevice.GetButtonCaps}
K{\footnote K TJvHidDevice,GetButtonCaps;GetButtonCaps,TJvHidDevice;GetButtonCaps}
A{\footnote A TJvHidDevice_GetButtonCaps;GetButtonCaps_Method;GetButtonCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetButtonCaps\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetButtonCaps(ButtonCaps: PHIDPButtonCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetButtonCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, ButtonCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetButtonCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetButtons}
${\footnote $ TJvHidDevice.GetButtons}
K{\footnote K TJvHidDevice,GetButtons;GetButtons,TJvHidDevice;GetButtons}
A{\footnote A TJvHidDevice_GetButtons;GetButtons_Method;GetButtons}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetButtons\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetButtons(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetButtons({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetButtons or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetButtonsEx}
${\footnote $ TJvHidDevice.GetButtonsEx}
K{\footnote K TJvHidDevice,GetButtonsEx;GetButtonsEx,TJvHidDevice;GetButtonsEx}
A{\footnote A TJvHidDevice_GetButtonsEx;GetButtonsEx_Method;GetButtonsEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetButtonsEx\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetButtonsEx(UsageList: PUsageAndPage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
{\f0 TUsageAndPage = packed record\line
  Usage:     TUsage;\line
  UsagePage: TUsage;\line
end;\par}
Calls {\f0 HidP_GetButtonsEx({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetButtonsEx or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetData}
${\footnote $ TJvHidDevice.GetData}
K{\footnote K TJvHidDevice,GetData;GetData,TJvHidDevice;GetData}
A{\footnote A TJvHidDevice_GetData;GetData_Method;GetData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetData\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetData(DataList: PHIDPData; {\b var} DataLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetData({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, DataList, DataLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetData or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetFeature}
${\footnote $ TJvHidDevice.GetFeature}
K{\footnote K TJvHidDevice,GetFeature;GetFeature,TJvHidDevice;GetFeature}
A{\footnote A TJvHidDevice_GetFeature;GetFeature_Method;GetFeature}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetFeature\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetFeature({\b var} Report; {\b const} Size: Integer): Boolean;}\par
Reads in a feature report from the device. Set the first byte of the report buffer to the report ID you want to read. 
Add this extra byte to the length of the report to read.\par
Calls {\f0 HidD_GetFeature({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, Size);}\par
The return value comes from HidD_GetFeature or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_GetScaledUsageValue}
${\footnote $ TJvHidDevice.GetScaledUsageValue}
K{\footnote K TJvHidDevice,GetScaledUsageValue;GetScaledUsageValue,TJvHidDevice;GetScaledUsageValue}
A{\footnote A TJvHidDevice_GetScaledUsageValue;GetScaledUsageValue_Method;GetScaledUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetScaledUsageValue\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetScaledUsageValue({\b var} UsageValue: Integer; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetScaledUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, 
{\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetScaledUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetSpecificButtonCaps}
${\footnote $ TJvHidDevice.GetSpecificButtonCaps}
K{\footnote K TJvHidDevice,GetSpecificButtonCaps;GetSpecificButtonCaps,TJvHidDevice;GetSpecificButtonCaps}
A{\footnote A TJvHidDevice_GetSpecificButtonCaps;GetSpecificButtonCaps_Method;GetSpecificButtonCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetSpecificButtonCaps\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetSpecificButtonCaps(ButtonCaps: PHIDPButtonCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetSpecificButtonCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, ButtonCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetSpecificButtonCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetSpecificValueCaps}
${\footnote $ TJvHidDevice.GetSpecificValueCaps}
K{\footnote K TJvHidDevice,GetSpecificValueCaps;GetSpecificValueCaps,TJvHidDevice;GetSpecificValueCaps}
A{\footnote A TJvHidDevice_GetSpecificValueCaps;GetSpecificValueCaps_Method;GetSpecificValueCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetSpecificValueCaps\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetSpecificValueCaps(ValueCaps: PHIDPValueCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetSpecificValueCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, ValueCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetSpecificValueCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsages}
${\footnote $ TJvHidDevice.GetUsages}
K{\footnote K TJvHidDevice,GetUsages;GetUsages,TJvHidDevice;GetUsages}
A{\footnote A TJvHidDevice_GetUsages;GetUsages_Method;GetUsages}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetUsages\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsages(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetUsages({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsages or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsagesEx}
${\footnote $ TJvHidDevice.GetUsagesEx}
K{\footnote K TJvHidDevice,GetUsagesEx;GetUsagesEx,TJvHidDevice;GetUsagesEx}
A{\footnote A TJvHidDevice_GetUsagesEx;GetUsagesEx_Method;GetUsagesEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetUsagesEx\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsagesEx(UsageList: PUsageAndPage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
{\f0 TUsageAndPage = packed record\line
  Usage:     TUsage;\line
  UsagePage: TUsage;\line
end;\par}
Calls {\f0 HidP_GetUsagesEx({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsagesEx or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsageValue}
${\footnote $ TJvHidDevice.GetUsageValue}
K{\footnote K TJvHidDevice,GetUsageValue;GetUsageValue,TJvHidDevice;GetUsageValue}
A{\footnote A TJvHidDevice_GetUsageValue;GetUsageValue_Method;GetUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetUsageValue\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsageValue({\b var} UsageValue: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsageValueArray}
${\footnote $ TJvHidDevice.GetUsageValueArray}
K{\footnote K TJvHidDevice,GetUsageValueArray;GetUsageValueArray,TJvHidDevice;GetUsageValueArray}
A{\footnote A TJvHidDevice_GetUsageValueArray;GetUsageValueArray_Method;GetUsageValueArray}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetUsageValueArray\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsageValueArray(UsageValue: PChar; UsageValueByteLength: WORD; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetUsageValueArray({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, UsageValueByteLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsageValueArray or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetValueCaps}
${\footnote $ TJvHidDevice.GetValueCaps}
K{\footnote K TJvHidDevice,GetValueCaps;GetValueCaps,TJvHidDevice;GetValueCaps}
A{\footnote A TJvHidDevice_GetValueCaps;GetValueCaps_Method;GetValueCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.GetValueCaps\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetValueCaps(ValueCaps: PHIDPValueCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetValueCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, ValueCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetValueCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_OpenFile}
${\footnote $ TJvHidDevice.OpenFile}
K{\footnote K TJvHidDevice,OpenFile;OpenFile,TJvHidDevice;OpenFile}
A{\footnote A TJvHidDevice_OpenFile;OpenFile_Method;OpenFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.OpenFile\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} OpenFile: Boolean;}\par
Opens the file handle {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} if not already opened. 
The file is closed with {\uldb CloseFile\v IDH_TJvHidDevice_CloseFile>Main}.\par
The return value is True for an already open or a successfully opened file.
\par\page

#{\footnote # IDH_TJvHidDevice_OpenFileEx}
${\footnote $ TJvHidDevice.OpenFileEx}
K{\footnote K TJvHidDevice,OpenFileEx;OpenFileEx,TJvHidDevice;OpenFileEx}
A{\footnote A TJvHidDevice_OpenFileEx;OpenFileEx_Method;OpenFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.OpenFileEx\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} OpenFileEx: Boolean;}\par
Opens the file handle {\uldb HidOverlappedHandle\v IDH_TJvHidDevice_HidOverlappedHandle>Main} if not already opened. 
The file is closed with {\uldb CloseFileEx\v IDH_TJvHidDevice_CloseFileEx>Main}.\par
The return value is True for an already open or a successfully opened file.
\par\page

#{\footnote # IDH_TJvHidDevice_ReadFile}
${\footnote $ TJvHidDevice.ReadFile}
K{\footnote K TJvHidDevice,ReadFile;ReadFile,TJvHidDevice;ReadFile}
A{\footnote A TJvHidDevice_ReadFile;ReadFile_Method;ReadFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.ReadFile\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} ReadFile({\b var} Report; ToRead: DWORD; {\b var} BytesRead: DWORD): Boolean;}\par
Calls {\f0 Windows.ReadFile({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, ToRead, BytesRead, {\b nil});}\par
The return value comes from Windows.ReadFile or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_ReadFileEx}
${\footnote $ TJvHidDevice.ReadFileEx}
K{\footnote K TJvHidDevice,ReadFileEx;ReadFileEx,TJvHidDevice;ReadFileEx}
A{\footnote A TJvHidDevice_ReadFileEx;ReadFileEx_Method;ReadFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.ReadFileEx\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} ReadFileEx({\b var} Report; ToRead: DWORD; CallBack: TPROverlappedCompletionRoutine): Boolean;}\par
Calls {\f0 Windows.ReadFileEx({\uldb HidOverlappedHandle\v IDH_TJvHidDevice_HidOverlappedHandle>Main}, Report, ToRead, Ovl, CallBack);}\par
The return value comes from Windows.ReadFileEx or {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main}.\line
Ovl is internal. Ovl.hEvent is initialized to {\f0 Ovl.hEvent := DWORD(Self);}.
\par\page

#{\footnote # IDH_TJvHidDevice_SetButtons}
${\footnote $ TJvHidDevice.SetButtons}
K{\footnote K TJvHidDevice,SetButtons;SetButtons,TJvHidDevice;SetButtons}
A{\footnote A TJvHidDevice_SetButtons;SetButtons_Method;SetButtons}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetButtons\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetButtons(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetButtons({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetButtons or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetData}
${\footnote $ TJvHidDevice.SetData}
K{\footnote K TJvHidDevice,SetData;SetData,TJvHidDevice;SetData}
A{\footnote A TJvHidDevice_SetData;SetData_Method;SetData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetData\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetData(DataList: PHIDPData; {\b var} DataLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetData({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, DataList, DataLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetData or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetFeature}
${\footnote $ TJvHidDevice.SetFeature}
K{\footnote K TJvHidDevice,SetFeature;SetFeature,TJvHidDevice;SetFeature}
A{\footnote A TJvHidDevice_SetFeature;SetFeature_Method;SetFeature}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetFeature\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetFeature({\b var} Report; {\b const} Size: Integer): Boolean;}\par
Writes a feature report to the device. Set the first byte of the report buffer to the report ID you want to write. 
Add this extra byte to the length of the report to write.\par
Calls {\f0 HidD_SetFeature({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, Size);}\par
The return value comes from HidD_SetFeature or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_SetScaledUsageValue}
${\footnote $ TJvHidDevice.SetScaledUsageValue}
K{\footnote K TJvHidDevice,SetScaledUsageValue;SetScaledUsageValue,TJvHidDevice;SetScaledUsageValue}
A{\footnote A TJvHidDevice_SetScaledUsageValue;SetScaledUsageValue_Method;SetScaledUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetScaledUsageValue\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} function SetScaledUsageValue(UsageValue: Integer; {\b var} Report; ReportLength: ULong): NTSTATUS;}\par
Calls {\f0 HidP_SetScaledUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetScaledUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetUsages}
${\footnote $ TJvHidDevice.SetUsages}
K{\footnote K TJvHidDevice,SetUsages;SetUsages,TJvHidDevice;SetUsages}
A{\footnote A TJvHidDevice_SetUsages;SetUsages_Method;SetUsages}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetUsages\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetUsages(UsageList: PUsage; {\b var} UsageLength: ULong; {\b var} Report; ReportLength: ULong): NTSTATUS;}\par
Calls {\f0 HidP_SetUsages({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetUsages or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetUsageValue}
${\footnote $ TJvHidDevice.SetUsageValue}
K{\footnote K TJvHidDevice,SetUsageValue;SetUsageValue,TJvHidDevice;SetUsageValue}
A{\footnote A TJvHidDevice_SetUsageValue;SetUsageValue_Method;SetUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetUsageValue\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetUsageValue(UsageValue: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetUsageValueArray}
${\footnote $ TJvHidDevice.SetUsageValueArray}
K{\footnote K TJvHidDevice,SetUsageValueArray;SetUsageValueArray,TJvHidDevice;SetUsageValueArray}
A{\footnote A TJvHidDevice_SetUsageValueArray;SetUsageValueArray_Method;SetUsageValueArray}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.SetUsageValueArray\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetUsageValueArray(UsageValue: PChar; UsageValueByteLength: WORD; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetUsageValueArray({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, UsageValueByteLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetUsageValueArray or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_UnsetButtons}
${\footnote $ TJvHidDevice.UnsetButtons}
K{\footnote K TJvHidDevice,UnsetButtons;UnsetButtons,TJvHidDevice;UnsetButtons}
A{\footnote A TJvHidDevice_UnsetButtons;UnsetButtons_Method;UnsetButtons}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.UnsetButtons\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} UnsetButtons(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_UnsetButtons({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_UnsetButtons or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_UnsetUsages}
${\footnote $ TJvHidDevice.UnsetUsages}
K{\footnote K TJvHidDevice,UnsetUsages;UnsetUsages,TJvHidDevice;UnsetUsages}
A{\footnote A TJvHidDevice_UnsetUsages;UnsetUsages_Method;UnsetUsages}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.UnsetUsages\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} UnsetUsages(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_UnsetUsages({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_UnsetUsages or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_WriteFile}
${\footnote $ TJvHidDevice.WriteFile}
K{\footnote K TJvHidDevice,WriteFile;WriteFile,TJvHidDevice;WriteFile}
A{\footnote A TJvHidDevice_WriteFile;WriteFile_Method;WriteFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.WriteFile\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} WriteFile({\b var} Report; ToWrite: DWORD; {\b var} BytesWritten: DWORD): Boolean;}\par
Calls {\f0 Windows.WriteFile({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, ToWrite, BytesWritten, {\b nil});}\par
The return value comes from Windows.WriteFile or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_WriteFileEx}
${\footnote $ TJvHidDevice.WriteFileEx}
K{\footnote K TJvHidDevice,WriteFileEx;WriteFileEx,TJvHidDevice;WriteFileEx}
A{\footnote A TJvHidDevice_WriteFileEx;WriteFileEx_Method;WriteFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDevice.WriteFileEx\b0}}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} WriteFileEx({\b var} Report; ToWrite: DWORD; CallBack: TPROverlappedCompletionRoutine): Boolean;}\par
Calls {\f0 Windows.WriteFileEx({\uldb HidOverlappedHandle\v IDH_TJvHidDevice_HidOverlappedHandle>Main}, Report, ToWrite, Ovl, CallBack);}\par
The return value comes from Windows.WriteFileEx or {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFile>Main}.
Ovl is internal. Ovl.hEvent is initialized to {\f0 Ovl.hEvent := DWORD(Self);}.
\par\page

#{\footnote # IDH_TJvHidDevice_OnUnplug}
${\footnote $ TJvHidDevice.OnUnplug}
K{\footnote K TJvHidDevice,OnUnplug;OnUnplug,TJvHidDevice;OnUnplug}
A{\footnote A TJvHidDevice_OnUnplug;OnUnplug_Event;OnUnplug}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDevice.OnUnplug\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidUnplugEvent = {\b procedure}(HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}) {\b of} {\b object};}\par
This event occurs if you pull the plug of the device. It is sent even for checked in devices. 
The object is already in unplugged state. No method will work.\line
You can assign the event function directly at runtime or for all devices at design time with {\uldb OnDeviceUnplug\v IDH_TJvHidDeviceController_OnDeviceUnplug>Main}.
\par\page

#{\footnote # IDH_Class_TJvHidDeviceController}
${\footnote $ TJvHidDeviceController}
K{\footnote K TJvHidDeviceController}
A{\footnote A TJvHidDeviceController_Object;TJvHidDeviceController}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\{bml usb.bmp\}\f1\fs28  \cf2 TJvHidDeviceController Object}\line
{\fs20{\ul Hierarchy\v IDH_Anym_3FAMT_2}    {\uldb Properties\v pme_cp_TJvHidDeviceController>pme}   {\uldb Methods\v pme_cm_TJvHidDeviceController>pme}   {\uldb Events\v pme_ce_TJvHidDeviceController>pme}\tab{\uldb Other\v pme_ce_Other>pme}}\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDeviceController = \b class\b0 (TComponent)}\par\pard\sa0\sb0{
#{\footnote # IDH_ClassTopic_TJvHidDeviceController_Properties}}
The main purpose of a TJvHidDeviceController object is to handle TJvHidDevice objects. 
For each plugged HID device the controller creates a TJvHidDevice object to represent the device. 
The controller monitors device plugs and unplugs. On device plug a new TJvHidDevice object is created. 
On unplug the object is not destroyed but is signalled and goes to an unplugged state.\line
The methods of TJvHidDeviceController are mainly for handing out TJvHidDevice objects by various criteria.\line
There is no need to instantiate more than one TJVHidDeviceController per program.
\par\page

#{\footnote # pme_cp_TJvHidDeviceController}
${\footnote $ Properties for TJvHidDeviceController}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Properties\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDeviceController\b0\line
\{bmct readonly.bmp\}\tab{\uldb HidGuid\v IDH_TJvHidDeviceController_HidGuid>Main}\line
\{bmct readonly.bmp\}\tab{\uldb NumCheckedInDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices>Main}\line
\{bmct readonly.bmp\}\tab{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedOutDevices>Main}\line
\{bmct readonly.bmp\}\tab{\uldb NumUnpluggedDevices\v IDH_TJvHidDeviceController_NumUnpluggedDevices>Main}
}\par\page

#{\footnote # pme_cm_TJvHidDeviceController}
${\footnote $ Methods for TJvHidDeviceController}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Methods\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDeviceController\b0\line
\{bmct empty.bmp\}\tab{\uldb CheckIn\v IDH_TJvHidDeviceController_CheckIn>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOut\v IDH_TJvHidDeviceController_CheckOut>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByID\v IDH_TJvHidDeviceController_CheckOutByID>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByIndex\v IDH_TJvHidDeviceController_CheckOutByIndex>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByProductName\v IDH_TJvHidDeviceController_CheckOutByProductName>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByVendorName\v IDH_TJvHidDeviceController_CheckOutByVendorName>Main}\line
\{bmct empty.bmp\}\tab{\uldb Create\v IDH_TJvHidDeviceController_Create>Main}\line
\{bmct empty.bmp\}\tab{\uldb Destroy\v IDH_TJvHidDeviceController_Destroy>Main}\line
\{bmct empty.bmp\}\tab{\uldb Enumerate\v IDH_TJvHidDeviceController_Enumerate>Main}
}\par\page

#{\footnote # pme_ce_TJvHidDeviceController}
${\footnote $ Events for TJvHidDeviceController}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Events\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDeviceController\b0\line
\{bmct Published.bmp\}\tab{\uldb OnDeviceChange\v IDH_TJvHidDeviceController_OnDeviceChange>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnDeviceUnplug\v IDH_TJvHidDeviceController_OnDeviceUnplug>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main}
}\par\page

#{\footnote # pme_ce_Other}
${\footnote $ HID functions not in scope}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Other\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b Functions not in component\b0\line
{\uldb HidD_Hello\v Other_HidD_Hello>Main}\line
{\uldb HidP_UsageListDifference\v Other_HidP_UsageListDifference>Main}\line
{\uldb HidP_TranslateUsagesToI8042ScanCodes\v Other_HidP_TranslateUsagesToI8042ScanCodes>Main}\line
{\uldb HidP_GetExtendedAttributes\v Other_HidP_GetExtendedAttributes>Main}\line
{\uldb HidP_InitializeReportForID\v Other_HidP_InitializeReportForID>Main}
}\par\page

#{\footnote # Other_HidD_Hello}
${\footnote $ HidD_Hello}
K{\footnote K HidD_Hello}
A{\footnote A HidD_Hello}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidD_Hello\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidD_Hello(Buffer: PChar; BufferLength: ULONG): ULONG; {\b stdcall};}\par
The undocumented easter egg function of HID.DLL. 
The function fills Buffer with\line
{\f0   'Hello\\nI hate Jello\\n'}\line
and returns the 
number of bytes filled in (StrLen(Buffer)+1 = 20).\par
The function does not check its parameters completely. 
Handing in {\f0\b nil} as buffer gives access violation. 
It always returns 20 even if buffer length is less than 20, 
but does not produce buffer overflow.
\par\page

#{\footnote # Other_HidP_UsageListDifference}
${\footnote $ HidP_UsageListDifference}
K{\footnote K HidP_UsageListDifference}
A{\footnote A HidP_UsageListDifference}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidP_UsageListDifference\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidP_UsageListDifference(PreviousUsageList: PUsage;\line
  CurrentUsageList: PUsage; BreakUsageList: PUsage;\line
  MakeUsageList: PUsage; UsageListLength: ULONG): NTSTATUS; {\b stdcall};}\par
Fills BreakUsageList with all usages which are in PreviousUsageList but not in CurrentUsageList. 
MakeUsageList is filled with all usages in CurrentUsageList but not in PreviousUsageList. 
UsageListLength is the length for all lists and should be the length of the longer of PreviousUsageList and CurrentUsageList. 
A Usage value of zero marks the end of a list.
\par\page

#{\footnote # Other_HidP_TranslateUsagesToI8042ScanCodes}
${\footnote $ HidP_TranslateUsagesToI8042ScanCodes}
K{\footnote K HidP_TranslateUsagesToI8042ScanCodes}
A{\footnote A HidP_TranslateUsagesToI8042ScanCodes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidP_TranslateUsagesToI8042ScanCodes\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidP_TranslateUsagesToI8042ScanCodes(\line
  ChangedUsageList: PUsage;\line
  UsageListLength: ULONG;\line
  KeyAction: THIDPKeyboardDirection;\line
  var ModifierState: THIDPKeyboardModifierState;\line
  InsertCodesProcedure: THIDPInsertScanCodes;\line
  InsertCodesContext: Pointer): NTSTATUS; {\b stdcall};}\par
There is no documentation for this function. It seems to be a utility function for a keyboard driver. 
It takes the raw data of USB keys and converts it to scan codes as if the keys are from a normal PC keyboard. 
This function is mainly for special USB keyboard drivers.
\par\page

#{\footnote # Other_HidP_GetExtendedAttributes}
${\footnote $ HidP_GetExtendedAttributes}
K{\footnote K HidP_GetExtendedAttributes}
A{\footnote A HidP_GetExtendedAttributes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidP_GetExtendedAttributes\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidP_GetExtendedAttributes(ReportType: THIDPReportType;\line
  DataIndex: Word; PreparsedData: PHIDPPreparsedData;\line
  Attributes: PHIDPExtendedAttributes;\line
  var LengthAttributes: ULONG): NTSTATUS; {\b stdcall};}\par
There is no documentation for this function. It is only implemented in the HID.DLL of Windows 98 SE and Windows 2000.
\par\page

#{\footnote # Other_HidP_InitializeReportForID}
${\footnote $ HidP_InitializeReportForID}
K{\footnote K HidP_InitializeReportForID}
A{\footnote A HidP_InitializeReportForID}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidP_InitializeReportForID\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidP_InitializeReportForID(ReportType: THIDPReportType;\line
  ReportID: BYTE; PreparsedData: PHIDPPreparsedData;\line
  {\b var} Report; ReportLength: ULONG): NTSTATUS; {\b stdcall};}\par
There is no documentation for this function. It is only implemented in the HID.DLL of Windows 98 SE and Windows 2000. 
This seems to be a simple initialization helper function.
\par\page

#{\footnote # pme_ce_Utilities}
${\footnote $ Utility functions for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Utilities\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b Utility functions for TJvHidDevice\b0\line
{\uldb HidCheck\v Utilities_HidCheck>Main}\line
{\uldb HidError\v Utilities_HidError>Main}\line
}\par\page

#{\footnote # Utilities_HidCheck}
${\footnote $ HidCheck}
K{\footnote K HidCheck}
A{\footnote A HidCheck}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidCheck\b0}\line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidCheck({\b const} RetVal: NTSTATUS): NTSTATUS; {\b overload};\line
{\b function} HidCheck({\b const} RetVal: LongBool): LongBool; {\b overload};}\par
This function checks the return value of a HID-function or method of 
a TJvHidDevice object. If the method returns an error HidCheck throws an exception 
by calling {\uldb HidError\v Utilities_HidError}. The return value is always RetVal.
\par\page

#{\footnote # Utilities_HidError}
${\footnote $ HidError}
K{\footnote K HidError}
A{\footnote A HidError}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b HidError\b0}\line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidError({\b const} RetVal: NTSTATUS): NTSTATUS;}\par
HidError throws an exception with an appropriate error text 
if RetVal is in the range of the HID error values. The return value is always RetVal.
\par\page

#{\footnote # IDH_TJvHidDeviceController_HidGuid}
${\footnote $ TJvHidDeviceController.HidGuid}
K{\footnote K TJvHidDeviceController,HidGuid;HidGuid,TJvHidDeviceController;HidGuid}
A{\footnote A TJvHidDeviceController_HidGuid;HidGuid_Property;HidGuid}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.HidGuid\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidGuid: TGUID;}\par
The GUID of the HID stack. It is of no importance for TJvHidDeviceController.\line
It is only present to provide all elements of the HID API if you want to enumerate the 
HID devices directly with SetupDiGetClassDevs() and SetupDiEnumDeviceInterfaces()  
from the Setup API conversion (SetupApi.pas, www.delphi-jedi.org).
\par\page

#{\footnote # IDH_TJvHidDeviceController_NumCheckedInDevices}
${\footnote $ TJvHidDeviceController.NumCheckedInDevices}
K{\footnote K TJvHidDeviceController,NumCheckedInDevices;NumCheckedInDevices,TJvHidDeviceController;NumCheckedInDevices}
A{\footnote A TJvHidDeviceController_NumCheckedInDevices;NumCheckedInDevices_Property;NumCheckedInDevices}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.NumCheckedInDevices\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumCheckedInDevices: Integer;}\par
The property tells the number of currently checked in HID devices. 
{\uldb NumCheckedInDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} + 
{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} tells the number of all controlled devices.
\par\page

#{\footnote # IDH_TJvHidDeviceController_NumCheckedOutDevices}
${\footnote $ TJvHidDeviceController.NumCheckedOutDevices}
K{\footnote K TJvHidDeviceController,NumCheckedOutDevices;NumCheckedOutDevices,TJvHidDeviceController;NumCheckedOutDevices}
A{\footnote A TJvHidDeviceController_NumCheckedOutDevices;NumCheckedOutDevices_Property;NumCheckedOutDevices}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.NumCheckedOutDevices\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumCheckedOutDevices: Integer;}\par
The property tells the number of currently checked out HID devices. 
{\uldb NumCheckedInDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} + 
{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} tells the number of all controlled devices.
\par\page

#{\footnote # IDH_TJvHidDeviceController_NumUnpluggedDevices}
${\footnote $ TJvHidDeviceController.NumUnpluggedDevices}
K{\footnote K TJvHidDeviceController,NumUnpluggedDevices;NumUnpluggedDevices,TJvHidDeviceController;NumUnpluggedDevices}
A{\footnote A TJvHidDeviceController_NumUnpluggedDevices;NumUnpluggedDevices_Property;NumUnpluggedDevices}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.NumUnpluggedDevices\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumUnpluggedDevices: Integer;}\par
The property tells the number of device objects where the device has been unplugged, but 
the device object has not been freed or checked back in yet.\line
{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} does not count such device objects 
despite the fact that they are formally in the state of being checked out.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckIn}
${\footnote $ TJvHidDeviceController.CheckIn}
K{\footnote K TJvHidDeviceController,CheckIn;CheckIn,TJvHidDeviceController;CheckIn}
A{\footnote A TJvHidDeviceController_CheckIn;CheckIn_Method;CheckIn}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckIn\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} CheckIn({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice});}\par
Gives a checked out {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice} object back to the TJvHidDeviceController.\line
Hand the object back if you are finished using it. 
CheckIn also sets HidDev to {\b nil} to prevent further use.\line
As an alternative call TJvHidDevice.Free. The TJvHidDeviceController gets informed and will create a new 
checked in TJvHidDevice object for the device if neccessary.\line
Destroying a TJvHidDeviceController with checked out TJvHidDevice objects results in pulling the virtual plug 
of all the TJvHidDevice objects. You will also receive an {\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main} event 
for each device unplugged if the event is connected. The TJvHidDevice objects remain but cease to work.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOut}
${\footnote $ TJvHidDeviceController.CheckOut}
K{\footnote K TJvHidDeviceController,CheckOut;CheckOut,TJvHidDeviceController;CheckOut}
A{\footnote A TJvHidDeviceController_CheckOut;CheckOut_Method;CheckOut}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckOut\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOut({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByClass}
${\footnote $ TJvHidDeviceController.CheckOutByClass}
K{\footnote K TJvHidDeviceController,CheckOutByClass;CheckOutByClass,TJvHidDeviceController;CheckOutByClass;cHidMouseClass;cHidKeyboardClass}
A{\footnote A TJvHidDeviceController_CheckOutByClass;CheckOutByClass_Method;CheckOutByClass}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckOutByClass\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByClass({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; ClassName: {\b string}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the device class matches the string of ClassName. 
The string is a user friendly class description and is defined in the registry under 
HKEY_LOCAL_MACHINE\\Enum\\HID\\...\\Class.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
The are two predefined string constants for ClassName:\line
{\f0 cHidMouseClass    = 'Mouse';}\line
{\f0 cHidKeyboardClass = 'Keyboard';}\line
For the other possible HID classes the information for the strings is missing.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByID}
${\footnote $ TJvHidDeviceController.CheckOutByID}
K{\footnote K TJvHidDeviceController,CheckOutByID;CheckOutByID,TJvHidDeviceController;CheckOutByID}
A{\footnote A TJvHidDeviceController_CheckOutByID;CheckOutByID_Method;CheckOutByID}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckOutByID\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByID({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; Vid, Pid: Integer): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the device VendorID and ProductID match Vid and Pid. 
The value -1 for Pid matches all ProductIDs.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByIndex}
${\footnote $ TJvHidDeviceController.CheckOutByIndex}
K{\footnote K TJvHidDeviceController,CheckOutByIndex;CheckOutByIndex,TJvHidDeviceController;CheckOutByIndex}
A{\footnote A TJvHidDeviceController_CheckOutByIndex;CheckOutByIndex_Method;CheckOutByIndex}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckOutByIndex\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByIndex({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; {\b const} Index: Integer): Boolean;}\par
Hands out the TJvHidDevice object with the index Index if it is not checked out already. 
The index is zero based. The {\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main} event provides the index of the enumerated device.\line
The return value is True if the index is within bounds and the TJvHidDevice object was not checked out already. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByProductName}
${\footnote $ TJvHidDeviceController.CheckOutByProductName}
K{\footnote K TJvHidDeviceController,CheckOutByProductName;CheckOutByProductName,TJvHidDeviceController;CheckOutByProductName}
A{\footnote A TJvHidDeviceController_CheckOutByProductName;CheckOutByProductName_Method;CheckOutByProductName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckOutByProductName\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByProductName({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; ProductName: {\b string}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the product name of the device matches ProductName. 
The product name comes directly from the firmware of the device. It may be an empty string.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByVendorName}
${\footnote $ TJvHidDeviceController.CheckOutByVendorName}
K{\footnote K TJvHidDeviceController,CheckOutByVendorName;CheckOutByVendorName,TJvHidDeviceController;CheckOutByVendorName}
A{\footnote A TJvHidDeviceController_CheckOutByVendorName;CheckOutByVendorName_Method;CheckOutByVendorName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.CheckOutByVendorName\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByVendorName({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; VendorName: {\b string}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the vendor name of the device matches VendorName. 
The vendor name comes directly from the firmware of the device. It may be an empty string.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_Create}
${\footnote $ TJvHidDeviceController.Create}
K{\footnote K TJvHidDeviceController,Create;Create,TJvHidDeviceController;Create}
A{\footnote A TJvHidDeviceController_Create;Create_Method;Create}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.Create\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b constructor} Create(AOwner: TComponent); {\b override};}\par
You may override the constructor if you like, but do not forget to call "{\b inherited} Create(AOwner);" 
as first statement of the overridden constructor or the whole component will never start to work.
\par\page

#{\footnote # IDH_TJvHidDeviceController_Destroy}
${\footnote $ TJvHidDeviceController.Destroy}
K{\footnote K TJvHidDeviceController,Destroy;Destroy,TJvHidDeviceController;Destroy}
A{\footnote A TJvHidDeviceController_Destroy;Destroy_Method;Destroy}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.Destroy\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b destructor} Destroy; {\b override};}\par
You may override the destructor if you like, but do not forget to call "{\b inherited} Destroy;" 
as last statement of the overridden destructor or the component cannot clean up correctly.
\par\page

#{\footnote # IDH_TJvHidDeviceController_Enumerate}
${\footnote $ TJvHidDeviceController.Enumerate}
K{\footnote K TJvHidDeviceController,Enumerate;Enumerate,TJvHidDeviceController;Enumerate}
A{\footnote A TJvHidDeviceController_Enumerate;Enumerate_Method;Enumerate}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{{\fs24\cf2\b TJvHidDeviceController.Enumerate\b0}}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} Enumerate: Integer;}\par
The Enumerate method fires an {\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main} 
event for each device in the list of the TJvHidDeviceController. This is the only way to get an OnEnumerate event. 
All devices in the list are enumerated. Checked in or not, plugged in or not. 
If the OnEnumerate event returns False the enumeration process stops prematurely.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnDeviceChange}
${\footnote $ TJvHidDeviceController.OnDeviceChange}
K{\footnote K TJvHidDeviceController,OnDeviceChange;OnDeviceChange,TJvHidDeviceController;OnDeviceChange}
A{\footnote A TJvHidDeviceController_OnDeviceChange;OnDeviceChange_Event;OnDeviceChange}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.OnDeviceChange\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TNotifyEvent = {\b procedure}(Sender: TObject) {\b of object};}\par
The TJvHidDeviceController fires this event each time a HID device is plugged or unplugged. 
The event is also fired at runtime when the OnDeviceChange is assigned the first time, 
which happens automatically at program start if the event has been set at design time. 
Fireing the event on assignment simulates the plug of all devices already plugged.\line
This is the place to check out a freshly arrived device. Sender is of course the TJvHidDeviceController component itself.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnDeviceUnplug}
${\footnote $ TJvHidDeviceController.OnDeviceUnplug}
K{\footnote K TJvHidDeviceController,OnDeviceUnplug;OnDeviceUnplug,TJvHidDeviceController;OnDeviceUnplug}
A{\footnote A TJvHidDeviceController_OnDeviceUnplug;OnDeviceUnplug_Event;OnDeviceUnplug}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.OnDeviceUnplug\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidUnplugEvent = {\b procedure}(HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}) {\b of} {\b object};}\par
This event is not for the TJvHidDeviceController but is set to the {\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main} 
event of each TJvHidDevice on creation. This allows to set the OnUnplug event for all TJvHidDevice objects at design time. 
Changing the OnOnplug event for an individual device is only possible at runtime. Only then the TJvHidDevice object exists.\line
Setting OnDeviceUnplug at runtime to a new value changes all TJvHidDevice.OnUnplug events which have the same old value. 
That is if you set a TJvHidDevice.OnUnplug to an individual event then it will not be changed by OnDeviceUnplug assignment.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnEnumerate}
${\footnote $ TJvHidDeviceController.OnEnumerate}
K{\footnote K TJvHidDeviceController,OnEnumerate;OnEnumerate,TJvHidDeviceController;OnEnumerate}
A{\footnote A TJvHidDeviceController_OnEnumerate;OnEnumerate_Event;OnEnumerate}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\fs24\cf2\b TJvHidDeviceController.OnEnumerate\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidEnumerateEvent = {\b function}(HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; Index: Integer): Boolean {\b of object};}\par
The OnEnumerate event is fired by the {\uldb Enumerate\v IDH_TJvHidDeviceController_Enumerate>Main} method for each device in the list of the TJvHidDeviceController. 
Returning False for this event stops the enumeration process prematurely.\line
All devices in the list are enumerated. Checked in or not, plugged in or not. 
It is explicitely allowed to check out or check in a device inside the event. 
This allows to implement complicated matches which are not covered by the CheckOut-methods. 
The Index is provided to check out a device with {\uldb CheckOutByIndex\v IDH_TJvHidDeviceController_CheckOutByIndex>Main}. 
\par\page

#{\footnote # IDH_Anym_3FAMT_1}
\sa50\sb50
{\f1\fs20\b Hierarchy\b0\par
TObject\line
      |\line
{\cf2 TJvHidDevice}\line
\line
\b Subclasses\b0\line
 None}\par\page

#{\footnote # IDH_Anym_3FAMT_2}
\sa50\sb50{\f1\fs20\b Hierarchy\b0\par
TComponent\line
      |\line
{\cf2 TJvHidDeviceController}\line
\line
\b Subclasses\b0\line
 None}\par\page

#{\footnote # IDH_Legend}
\sa50\sb50
{\f1\fs20\b Scope\b0\line
\{bmct Published.bmp\}\tab Published\par
\b Accessibility\b0\line
\{bmct readonly.bmp\}\tab Read-only
}\par\page
}
